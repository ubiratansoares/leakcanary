public final class com/squareup/leakcanary/release/BuildConfig {
	public static final field BUILD_TYPE Ljava/lang/String;
	public static final field DEBUG Z
	public static final field GIT_SHA Ljava/lang/String;
	public static final field LIBRARY_PACKAGE_NAME Ljava/lang/String;
	public static final field LIBRARY_VERSION Ljava/lang/String;
	public static final field VERSION_CODE I
	public static final field VERSION_NAME Ljava/lang/String;
	public fun <init> ()V
}

public final class leakcanary/BackgroundTrigger {
	public fun <init> (Landroid/app/Application;Lleakcanary/HeapAnalysisClient;Ljava/util/concurrent/Executor;Lkotlin/jvm/functions/Function1;)V
	public synthetic fun <init> (Landroid/app/Application;Lleakcanary/HeapAnalysisClient;Ljava/util/concurrent/Executor;Lkotlin/jvm/functions/Function1;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
	public final fun start ()V
	public final fun stop ()V
}

public final class leakcanary/GoodAndroidVersionInterceptor : leakcanary/HeapAnalysisInterceptor {
	public fun <init> ()V
	public fun intercept (Lleakcanary/HeapAnalysisInterceptor$Chain;)Lleakcanary/HeapAnalysisJob$Result;
}

public final class leakcanary/HeapAnalysisClient {
	public static final field Companion Lleakcanary/HeapAnalysisClient$Companion;
	public fun <init> (Ljava/io/File;Lleakcanary/HeapAnalysisConfig;Ljava/util/List;)V
	public final fun deleteHeapDumpFiles ()V
	public final fun newJob (Ljava/lang/String;)Lleakcanary/HeapAnalysisJob;
}

public final class leakcanary/HeapAnalysisClient$Companion {
	public final fun defaultInterceptors (Landroid/app/Application;)Ljava/util/List;
}

public final class leakcanary/HeapAnalysisConfig {
	public fun <init> ()V
	public fun <init> (Ljava/util/List;Ljava/util/List;Lshark/MetadataExtractor;ZLshark/LeakingObjectFinder;Z)V
	public synthetic fun <init> (Ljava/util/List;Ljava/util/List;Lshark/MetadataExtractor;ZLshark/LeakingObjectFinder;ZILkotlin/jvm/internal/DefaultConstructorMarker;)V
	public final fun component1 ()Ljava/util/List;
	public final fun component2 ()Ljava/util/List;
	public final fun component3 ()Lshark/MetadataExtractor;
	public final fun component4 ()Z
	public final fun component5 ()Lshark/LeakingObjectFinder;
	public final fun component6 ()Z
	public final fun copy (Ljava/util/List;Ljava/util/List;Lshark/MetadataExtractor;ZLshark/LeakingObjectFinder;Z)Lleakcanary/HeapAnalysisConfig;
	public static synthetic fun copy$default (Lleakcanary/HeapAnalysisConfig;Ljava/util/List;Ljava/util/List;Lshark/MetadataExtractor;ZLshark/LeakingObjectFinder;ZILjava/lang/Object;)Lleakcanary/HeapAnalysisConfig;
	public fun equals (Ljava/lang/Object;)Z
	public final fun getComputeRetainedHeapSize ()Z
	public final fun getLeakingObjectFinder ()Lshark/LeakingObjectFinder;
	public final fun getMetadataExtractor ()Lshark/MetadataExtractor;
	public final fun getObjectInspectors ()Ljava/util/List;
	public final fun getReferenceMatchers ()Ljava/util/List;
	public final fun getStripHeapDump ()Z
	public fun hashCode ()I
	public fun toString ()Ljava/lang/String;
}

public abstract interface class leakcanary/HeapAnalysisInterceptor {
	public abstract fun intercept (Lleakcanary/HeapAnalysisInterceptor$Chain;)Lleakcanary/HeapAnalysisJob$Result;
}

public abstract interface class leakcanary/HeapAnalysisInterceptor$Chain {
	public abstract fun canceled (Ljava/lang/String;)Lleakcanary/HeapAnalysisJob$Result$Canceled;
	public abstract fun getJob ()Lleakcanary/HeapAnalysisJob;
	public abstract fun proceed ()Lleakcanary/HeapAnalysisJob$Result;
}

public abstract interface class leakcanary/HeapAnalysisJob {
	public abstract fun cancel (Ljava/lang/String;)V
	public abstract fun execute ()Lleakcanary/HeapAnalysisJob$Result;
	public abstract fun getCanceled ()Z
	public abstract fun getExecuted ()Z
	public abstract fun getStartReason ()Ljava/lang/String;
}

public abstract class leakcanary/HeapAnalysisJob$Result {
	public abstract fun getStartReason ()Ljava/lang/String;
}

public final class leakcanary/HeapAnalysisJob$Result$Canceled : leakcanary/HeapAnalysisJob$Result {
	public fun <init> (Ljava/lang/String;Ljava/lang/String;)V
	public final fun component1 ()Ljava/lang/String;
	public final fun component2 ()Ljava/lang/String;
	public final fun copy (Ljava/lang/String;Ljava/lang/String;)Lleakcanary/HeapAnalysisJob$Result$Canceled;
	public static synthetic fun copy$default (Lleakcanary/HeapAnalysisJob$Result$Canceled;Ljava/lang/String;Ljava/lang/String;ILjava/lang/Object;)Lleakcanary/HeapAnalysisJob$Result$Canceled;
	public fun equals (Ljava/lang/Object;)Z
	public final fun getCancelReason ()Ljava/lang/String;
	public fun getStartReason ()Ljava/lang/String;
	public fun hashCode ()I
	public fun toString ()Ljava/lang/String;
}

public final class leakcanary/HeapAnalysisJob$Result$Done : leakcanary/HeapAnalysisJob$Result {
	public fun <init> (Ljava/lang/String;Lshark/HeapAnalysis;)V
	public final fun component1 ()Ljava/lang/String;
	public final fun component2 ()Lshark/HeapAnalysis;
	public final fun copy (Ljava/lang/String;Lshark/HeapAnalysis;)Lleakcanary/HeapAnalysisJob$Result$Done;
	public static synthetic fun copy$default (Lleakcanary/HeapAnalysisJob$Result$Done;Ljava/lang/String;Lshark/HeapAnalysis;ILjava/lang/Object;)Lleakcanary/HeapAnalysisJob$Result$Done;
	public fun equals (Ljava/lang/Object;)Z
	public final fun getAnalysis ()Lshark/HeapAnalysis;
	public fun getStartReason ()Ljava/lang/String;
	public fun hashCode ()I
	public fun toString ()Ljava/lang/String;
}

public final class leakcanary/MinimumDiskSpaceInterceptor : leakcanary/HeapAnalysisInterceptor {
	public fun <init> (Landroid/app/Application;J)V
	public synthetic fun <init> (Landroid/app/Application;JILkotlin/jvm/internal/DefaultConstructorMarker;)V
	public fun intercept (Lleakcanary/HeapAnalysisInterceptor$Chain;)Lleakcanary/HeapAnalysisJob$Result;
}

public final class leakcanary/MinimumElapsedSinceStartInterceptor : leakcanary/HeapAnalysisInterceptor {
	public fun <init> ()V
	public fun <init> (J)V
	public synthetic fun <init> (JILkotlin/jvm/internal/DefaultConstructorMarker;)V
	public fun intercept (Lleakcanary/HeapAnalysisInterceptor$Chain;)Lleakcanary/HeapAnalysisJob$Result;
}

public final class leakcanary/MinimumMemoryInterceptor : leakcanary/HeapAnalysisInterceptor {
	public fun <init> (Landroid/app/Application;J)V
	public synthetic fun <init> (Landroid/app/Application;JILkotlin/jvm/internal/DefaultConstructorMarker;)V
	public fun intercept (Lleakcanary/HeapAnalysisInterceptor$Chain;)Lleakcanary/HeapAnalysisJob$Result;
}

public final class leakcanary/OncePerPeriodInterceptor : leakcanary/HeapAnalysisInterceptor {
	public static final field Companion Lleakcanary/OncePerPeriodInterceptor$Companion;
	public fun <init> (Landroid/app/Application;J)V
	public synthetic fun <init> (Landroid/app/Application;JILkotlin/jvm/internal/DefaultConstructorMarker;)V
	public fun intercept (Lleakcanary/HeapAnalysisInterceptor$Chain;)Lleakcanary/HeapAnalysisJob$Result;
}

public final class leakcanary/OncePerPeriodInterceptor$Companion {
}

public final class leakcanary/SaveResourceIdsInterceptor : leakcanary/HeapAnalysisInterceptor {
	public fun <init> (Landroid/content/res/Resources;)V
	public fun intercept (Lleakcanary/HeapAnalysisInterceptor$Chain;)Lleakcanary/HeapAnalysisJob$Result;
}

